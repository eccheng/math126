// Generated by CoffeeScript 1.6.3
var MarchingCubesModel, MathModel, MathScene, ParametricPathModel,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

MathScene = (function() {
  MathScene.prototype.HEIGHT = 400;

  MathScene.prototype.WIDTH = 700;

  MathScene.prototype.shadow = null;

  MathScene.prototype.live = null;

  MathScene.prototype.guiActive = false;

  function MathScene(containerName) {
    this.renderloop = __bind(this.renderloop, this);
    if (containerName != null) {
      this.container = document.getElementById(containerName);
    } else {
      this.container = document.body.appendChild(document.createElement("div"));
    }
    this.container.style.position = "relative";
    this.populate();
    this.mathUp();
    this.live = true;
    this.shadow = false;
    this.guiActive = false;
  }

  MathScene.prototype.setrenderer = function() {
    if (Detector.webgl) {
      this.renderer = new THREE.WebGLRenderer({
        preserveDrawingBuffer: true,
        antialias: true
      });
      this.renderer.setClearColor(0xfcfcfc, 1);
    } else {
      this.renderer = new THREE.CanvasRenderer();
    }
  };

  MathScene.prototype.loader = new THREE.JSONLoader(true);

  MathScene.prototype.populate = function() {
    this.scene = new THREE.Scene();
    this.scene.add(new THREE.AmbientLight(0xffffff));
    this.scene.add(new THREE.DirectionalLight(0xffffff));
    if (!this.camera) {
      this.camera = new THREE.PerspectiveCamera(45, this.WIDTH / this.HEIGHT);
      this.camera.position.set(3, 3, 3);
    }
    if (this.shadow) {
      this.renderer.shadowMapEnabled = true;
      this.renderer.shadowMapSoft = true;
      this.renderer.shadowCameraNear = 3;
      this.renderer.shadowCameraFar = this.camera.far;
      this.renderer.shadowCameraFov = 50;
      this.renderer.shadowMapBias = 0.0039;
      this.renderer.shadowMapDarkness = 1.0;
      this.renderer.shadowMapWidth = 1024;
      this.renderer.shadowMapHeight = 1024;
      this.pointLight = new THREE.SpotLight(0xffffff);
      this.pointLight.castShadow = true;
    } else {
      this.pointLight = new THREE.PointLight(0xffffff);
    }
    this.pointLight.intensity = 1;
    this.pointLight.position.set(0, 0, 100);
    this.scene.add(this.pointLight);
    this.scene.add(this.camera);
    this.setrenderer();
    this.renderer.setSize(this.WIDTH, this.HEIGHT);
    this.renderer.domElement.style.position = "relative";
    this.container.appendChild(this.renderer.domElement);
    this.renderer.clear();
    this.gui = new dat.GUI({
      autoPlace: false
    });
    this.gui.domElement.style.position = "absolute";
    this.gui.domElement.style.left = 0;
    this.gui.domElement.style.top = 0;
    this.gui.close();
    this.cameraControls = new THREE.TrackballControls(this.camera, this.renderer.domElement);
    this.cameraControls.target.set(0, 0, 0);
    return null;
  };

  MathScene.prototype.activateGui = function() {
    if (!this.guiActive) {
      this.container.appendChild(this.gui.domElement);
      this.guiActive = true;
    }
    return null;
  };

  MathScene.prototype.mathUp = function() {
    return this.camera.up = new THREE.Vector3(0, 0, 1);
  };

  MathScene.prototype.addaxes = function(length) {
    this.scene.add(new THREE.AxisHelper(length));
    return null;
  };

  MathScene.prototype.render = function() {
    if (this.live) {
      this.cameraControls.update();
      this.pointLight.position = this.camera.position;
    }
    this.renderer.render(this.scene, this.camera);
    return null;
  };

  MathScene.prototype.calc = function(t) {};

  MathScene.prototype.animate = function() {
    var framing, self;
    self = this;
    framing = function(t) {
      self.calc(t);
      self.render();
      if (self.live) {
        requestAnimationFrame(framing, self.container);
      }
      return null;
    };
    framing(new Date().getTime());
    return null;
  };

  MathScene.prototype.initTime = 3000;

  MathScene.prototype.renderloop = function() {
    this.live = true;
    return this.animate();
  };

  MathScene.prototype.init = function() {
    var T;
    T = new Date().getTime();
    this.live = false;
    this.render();
    return null;
  };

  MathScene.prototype.go = function() {
    this.init();
    return null;
  };

  return MathScene;

})();

MathModel = (function() {
  function MathModel() {}

  MathModel.prototype.calc = null;

  MathModel.prototype.needsGui = false;

  MathModel.prototype.embedInScene = function(mathScene) {
    var old_calc, that;
    this.mathScene = mathScene;
    this.embedObjects();
    that = this;
    old_calc = mathScene.calc;
    mathScene.calc = function(t) {
      if (that.calc != null) {
        that.calc()(t);
      }
      old_calc(t);
      return null;
    };
    if (this.needsGui) {
      mathScene.activateGui();
      this.addGui(mathScene.gui);
    }
    return null;
  };

  return MathModel;

})();

ParametricPathModel = (function(_super) {
  __extends(ParametricPathModel, _super);

  ParametricPathModel.prototype.limits = [-1, 1];

  ParametricPathModel.prototype.speed = 2;

  ParametricPathModel.prototype.resolution = 100;

  ParametricPathModel.prototype.mover = null;

  ParametricPathModel.prototype.calc = null;

  ParametricPathModel.prototype.objects = null;

  ParametricPathModel.prototype.needsGui = false;

  function ParametricPathModel(x, y, z, limits, speed) {
    var geometry, i, t, _i;
    this.x = x;
    this.y = y;
    this.z = z;
    if (limits == null) {
      limits = [-1, 1];
    }
    if (speed == null) {
      speed = 2;
    }
    this.limits = limits;
    this.speed = speed;
    this.mover = new THREE.Mesh(new THREE.SphereGeometry(0.03), new THREE.MeshNormalMaterial());
    this.calc = function() {
      var self;
      self = this;
      return function(t) {
        var T;
        T = self.speed * t / 1000;
        self.mover.position.set(self.x(T), self.y(T), self.z(T));
        return null;
      };
    };
    geometry = new THREE.Geometry();
    for (i = _i = 1; _i <= 100; i = ++_i) {
      t = this.limits[0] + (this.limits[1] - this.limits[0]) * i / 100.0;
      geometry.vertices.push(new THREE.Vector3(this.x(t), this.y(t), this.z(t)));
    }
    this.path = new THREE.Line(geometry, new THREE.LineBasicMaterial({
      color: 0xff0000
    }));
  }

  ParametricPathModel.prototype.embedObjects = function() {
    this.mathScene.scene.add(this.mover);
    return this.mathScene.scene.add(this.path);
  };

  return ParametricPathModel;

})(MathModel);

MarchingCubesModel = (function(_super) {
  __extends(MarchingCubesModel, _super);

  MarchingCubesModel.prototype.xmin = -3.00;

  MarchingCubesModel.prototype.xmax = 3.00;

  MarchingCubesModel.prototype.ymin = -3.00;

  MarchingCubesModel.prototype.ymax = 3.00;

  MarchingCubesModel.prototype.zmin = -3.00;

  MarchingCubesModel.prototype.zmax = 3.00;

  MarchingCubesModel.prototype.level = 0;

  MarchingCubesModel.prototype.func = null;

  MarchingCubesModel.prototype.resolution = 40;

  MarchingCubesModel.prototype.calc = null;

  MarchingCubesModel.prototype.smoothingLevel = 0;

  MarchingCubesModel.prototype.needsGui = false;

  MarchingCubesModel.prototype.name = "";

  MarchingCubesModel.prototype.scene = null;

  MarchingCubesModel.prototype.surface = null;

  function MarchingCubesModel(_arg) {
    this.func = _arg.func, this.xmin = _arg.xmin, this.xmax = _arg.xmax, this.ymin = _arg.ymin, this.ymax = _arg.ymax, this.zmin = _arg.zmin, this.zmax = _arg.zmax, this.resolution = _arg.resolution, this.smoothingLevel = _arg.smoothingLevel, this.material = _arg.material, this.name = _arg.name;
    if (this.xmin == null) {
      this.xmin = -3.00;
    }
    if (this.xmax == null) {
      this.xmax = 3.00;
    }
    if (this.ymin == null) {
      this.ymin = -3.00;
    }
    if (this.ymax == null) {
      this.ymax = 3.00;
    }
    if (this.zmin == null) {
      this.zmin = -3.00;
    }
    if (this.zmax == null) {
      this.zmax = 3.00;
    }
    if (this.resolution == null) {
      this.resolution = 40;
    }
    if (this.smoothingLevel == null) {
      this.smoothingLevel = 0;
    }
    if (this.material == null) {
      this.material = new THREE.MeshNormalMaterial({
        side: THREE.DoubleSide
      });
    }
    if (this.name == null) {
      this.name = "Surface";
    }
    this.debug = false;
    this.march_async(true);
    this.needsGui = true;
  }

  MarchingCubesModel.prototype.embedObjects = function() {
    this.march_async(true);
    return null;
  };

  MarchingCubesModel.prototype.rerender = function() {
    var geom;
    if (this.mathScene != null) {
      this.mathScene.scene.remove(this.surface);
      console.log("surface removed");
      geom = this.march();
      this.surface = new THREE.Mesh(geom, this.material);
      console.log("surface constructed");
      this.mathScene.scene.add(this.surface);
      console.log("surface embedded");
    }
    return null;
  };

  MarchingCubesModel.prototype.rerender_async = function() {
    return this.march_async(true);
  };

  MarchingCubesModel.prototype.addGui = function(gui) {
    var f;
    f = gui.addFolder(this.name);
    f.add(this, 'xmin').step(0.05);
    f.add(this, 'xmax').step(0.05);
    f.add(this, 'ymin').step(0.05);
    f.add(this, 'ymax').step(0.05);
    f.add(this, 'zmin').step(0.05);
    f.add(this, 'zmax').step(0.05);
    f.add(this, 'resolution', 40, 150).step(1);
    f.add(this, 'smoothingLevel', 0, 2).step(1);
    f.add(this, 'rerender_async');
    f.add(this, 'debug');
    f.open();
    return null;
  };

  MarchingCubesModel.prototype.march_async = function(b) {
    var blob, debug, e, f, mc, response, that, worker;
    that = this;
    debug = this.debug;
    window.URL = window.URL || window.webkitURL;
    f = this.func.toString();
    mc = marchingCubes.toString();
    response = "marchingCubes = " + mc + "\nself.onmessage = function (e) {\n  output = marchingCubes([" + this.resolution + ", " + this.resolution + ", " + this.resolution + "], " + f + ", [[" + this.xmin + ", " + this.ymin + ", " + this.zmin + "],[" + this.xmax + ", " + this.ymax + ", " + this.zmax + "]]);\n  postMessage(output);\n  } ";
    blob = null;
    try {
      blob = new Blob([response], {
        type: 'application/javascript'
      });
    } catch (_error) {
      e = _error;
      window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
      blob = new BlobBuilder();
      blob.append(response);
      blob = blob.getBlob();
    }
    worker = new Worker(URL.createObjectURL(blob));
    worker.onmessage = function(e) {
      var flat_normals, flat_positions, geometry, new_surface, raw_data, smooth;
      raw_data = e.data;
      console.log(raw_data);
      flat_positions = raw_data.positions;
      flat_normals = raw_data.normals;
      geometry = new THREE.BufferGeometry();
      geometry.addAttribute('position', new THREE.BufferAttribute(flat_positions, 3));
      geometry.addAttribute('normal', new THREE.BufferAttribute(flat_normals, 3));
      smooth = geometry;
      new_surface = new THREE.Mesh(smooth, that.material);
      if (b) {
        if (that.mathScene != null) {
          that.mathScene.scene.remove(that.surface);
          console.log("surface removed");
          that.surface = new_surface;
          console.log("surface constructed");
          that.mathScene.scene.add(that.surface);
          console.log("surface embedded");
        }
      }
      return null;
    };
    worker.postMessage("Go!");
    return null;
  };

  MarchingCubesModel.prototype.march = function() {
    var bits, cubeindex, debug, f, face, geometry, i, index1, index2, index3, isolevel, j, k, l, mu, p, points, px, pxy, pxyz, pxz, py, pyz, pz, size, size2, smooth, value, value0, value1, value2, value3, value4, value5, value6, value7, values, vertexIndex, vlist, x, xMin, xRange, y, yMin, yRange, z, zMin, zRange, _i, _j, _k, _l, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
    points = [];
    values = [];
    debug = this.debug;
    if (debug) {
      console.log(this.xmin);
      console.log(this.xmax);
      console.log(this.ymin);
      console.log(this.ymax);
      console.log(this.zmin);
      console.log(this.zmax);
    }
    xMin = this.xmin;
    xRange = this.xmax - this.xmin;
    yMin = this.ymin;
    yRange = this.ymax - this.ymin;
    zMin = this.zmin;
    zRange = this.zmax - this.zmin;
    size = this.resolution;
    f = this.func;
    l = this.level;
    for (k = _i = 0, _ref = size - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; k = 0 <= _ref ? ++_i : --_i) {
      for (j = _j = 0, _ref1 = size - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
        for (i = _k = 0, _ref2 = size - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
          x = xMin + xRange * i / (size - 1);
          y = yMin + yRange * j / (size - 1);
          z = zMin + zRange * k / (size - 1);
          points.push(new THREE.Vector3(x, y, z));
          value = f(x, y, z) - l;
          values.push(value);
        }
      }
    }
    console.log(points.length + " values computed");
    size2 = size * size;
    vlist = new Array(12);
    geometry = new THREE.Geometry();
    vertexIndex = 0;
    for (z = _l = 0, _ref3 = size - 1; 0 <= _ref3 ? _l <= _ref3 : _l >= _ref3; z = 0 <= _ref3 ? ++_l : --_l) {
      for (y = _m = 0, _ref4 = size - 1; 0 <= _ref4 ? _m <= _ref4 : _m >= _ref4; y = 0 <= _ref4 ? ++_m : --_m) {
        for (x = _n = 0, _ref5 = size - 1; 0 <= _ref5 ? _n <= _ref5 : _n >= _ref5; x = 0 <= _ref5 ? ++_n : --_n) {
          p = x + size * y + size2 * z;
          px = p + 1;
          py = p + size;
          pxy = py + 1;
          pz = p + size2;
          pxz = px + size2;
          pyz = py + size2;
          pxyz = pxy + size2;
          value0 = values[p];
          value1 = values[px];
          value2 = values[py];
          value3 = values[pxy];
          value4 = values[pz];
          value5 = values[pxz];
          value6 = values[pyz];
          value7 = values[pxyz];
          isolevel = 0;
          cubeindex = 0;
          if (value0 < isolevel) {
            cubeindex |= 1;
          }
          if (value1 < isolevel) {
            cubeindex |= 2;
          }
          if (value2 < isolevel) {
            cubeindex |= 8;
          }
          if (value3 < isolevel) {
            cubeindex |= 4;
          }
          if (value4 < isolevel) {
            cubeindex |= 16;
          }
          if (value5 < isolevel) {
            cubeindex |= 32;
          }
          if (value6 < isolevel) {
            cubeindex |= 128;
          }
          if (value7 < isolevel) {
            cubeindex |= 64;
          }
          bits = THREE.edgeTable[cubeindex];
          if (bits === 0) {
            continue;
          }
          mu = 0.5;
          if (bits & 1) {
            mu = (isolevel - value0) / (value1 - value0);
            vlist[0] = points[p].clone().lerp(points[px], mu);
          }
          if (bits & 2) {
            mu = (isolevel - value1) / (value3 - value1);
            vlist[1] = points[px].clone().lerp(points[pxy], mu);
          }
          if (bits & 4) {
            mu = (isolevel - value2) / (value3 - value2);
            vlist[2] = points[py].clone().lerp(points[pxy], mu);
          }
          if (bits & 8) {
            mu = (isolevel - value0) / (value2 - value0);
            vlist[3] = points[p].clone().lerp(points[py], mu);
          }
          if (bits & 16) {
            mu = (isolevel - value4) / (value5 - value4);
            vlist[4] = points[pz].clone().lerp(points[pxz], mu);
          }
          if (bits & 32) {
            mu = (isolevel - value5) / (value7 - value5);
            vlist[5] = points[pxz].clone().lerp(points[pxyz], mu);
          }
          if (bits & 64) {
            mu = (isolevel - value6) / (value7 - value6);
            vlist[6] = points[pyz].clone().lerp(points[pxyz], mu);
          }
          if (bits & 128) {
            mu = (isolevel - value4) / (value6 - value4);
            vlist[7] = points[pz].clone().lerp(points[pyz], mu);
          }
          if (bits & 256) {
            mu = (isolevel - value0) / (value4 - value0);
            vlist[8] = points[p].clone().lerp(points[pz], mu);
          }
          if (bits & 512) {
            mu = (isolevel - value1) / (value5 - value1);
            vlist[9] = points[px].clone().lerp(points[pxz], mu);
          }
          if (bits & 1024) {
            mu = (isolevel - value3) / (value7 - value3);
            vlist[10] = points[pxy].clone().lerp(points[pxyz], mu);
          }
          if (bits & 2048) {
            mu = (isolevel - value2) / (value6 - value2);
            vlist[11] = points[py].clone().lerp(points[pyz], mu);
          }
          i = 0;
          cubeindex <<= 4;
          while (THREE.triTable[cubeindex + i] !== -1) {
            index1 = THREE.triTable[cubeindex + i];
            index2 = THREE.triTable[cubeindex + i + 1];
            index3 = THREE.triTable[cubeindex + i + 2];
            geometry.vertices.push(vlist[index1].clone());
            geometry.vertices.push(vlist[index2].clone());
            geometry.vertices.push(vlist[index3].clone());
            face = new THREE.Face3(vertexIndex, vertexIndex + 1, vertexIndex + 2);
            geometry.faces.push(face);
            geometry.faceVertexUvs[0].push([new THREE.Vector2(0, 0), new THREE.Vector2(0, 1), new THREE.Vector2(1, 1)]);
            vertexIndex += 3;
            i += 3;
          }
        }
      }
    }
    if (debug) {
      console.log(geometry.vertices.length + " vertices created");
    }
    geometry.mergeVertices();
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();
    if (debug) {
      console.log(geometry);
    }
    smooth = this.modify(geometry);
    return smooth;
  };

  MarchingCubesModel.prototype.modify = function(geometry) {
    var modifier, smooth;
    smooth = geometry.clone();
    smooth.mergeVertices();
    modifier = new THREE.SubdivisionModifier(this.smoothingLevel);
    modifier.modify(smooth);
    return smooth;
  };

  return MarchingCubesModel;

})(MathModel);

window.MathScene = MathScene;

window.ParametricPathModel = ParametricPathModel;

window.MarchingCubesModel = MarchingCubesModel;
